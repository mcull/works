"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
exports.__esModule = true;
exports.prepareFileCdnHandler = prepareFileCdnHandler;
var _fsExtra = _interopRequireDefault(require("fs-extra"));
var path = _interopRequireWildcard(require("path"));
var _package = _interopRequireDefault(require("gatsby-adapter-netlify/package.json"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
async function prepareFileCdnHandler({
  pathPrefix,
  remoteFileAllowedUrls
}) {
  var _packageJson$version;
  const functionId = `file-cdn`;
  const edgeFunctionsManifestPath = path.join(process.cwd(), `.netlify`, `edge-functions`, `manifest.json`);
  const fileCdnEdgeFunction = path.join(process.cwd(), `.netlify`, `edge-functions`, `${functionId}`, `${functionId}.mts`);
  const handlerSource = /* typescript */`
    const allowedUrlPatterns = [${remoteFileAllowedUrls.map(allowedUrl => `new RegExp(\`${allowedUrl.regexSource}\`)`)}]

    export default async (req: Request): Promise<Response> => {
      const url = new URL(req.url)
      const remoteUrl = url.searchParams.get("url")
      
      const isAllowed = allowedUrlPatterns.some(allowedUrlPattern => allowedUrlPattern.test(remoteUrl))
      if (isAllowed) {
        return fetch(remoteUrl);
      } else {
        console.error(\`URL not allowed: \${remoteUrl}\`)
        return new Response("Bad request", { status: 500 })
      }
    }
  `;
  await _fsExtra.default.outputFileSync(fileCdnEdgeFunction, handlerSource);
  const manifest = {
    functions: [{
      path: `${pathPrefix}/_gatsby/file/*`,
      function: functionId,
      generator: `gatsby-adapter-netlify@${(_packageJson$version = _package.default === null || _package.default === void 0 ? void 0 : _package.default.version) !== null && _packageJson$version !== void 0 ? _packageJson$version : `unknown`}`
    }],
    layers: [],
    version: 1
  };
  await _fsExtra.default.outputJSON(edgeFunctionsManifestPath, manifest);
}